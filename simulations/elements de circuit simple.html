<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulation : L'Interrupteur (Corrig√©)</title>

    <style>
        /* --- CSS SETUP --- */
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            width: 100%;
            height: 100%;
            touch-action: none;
            font-family: system-ui, -apple-system, 'Segoe UI', sans-serif;
            user-select: none;
            -webkit-user-select: none;
            transition: background-color 1s ease;
        }

        #sim-wrapper {
            width: 1024px;
            height: 640px;
            position: absolute;
            transform-origin: top left;
            overflow: hidden;
            transition: background 1s ease;
        }

        /* UI */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .ui-top-bar {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: auto;
            z-index: 10;
        }

        .instruction-card {
            background: #fff;
            padding: 15px 25px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            max-width: 55%;
            border-left: 5px solid #0984e3;
            transition: transform 0.3s ease;
        }

        h1 {
            margin: 0 0 5px 0;
            font-size: 22px;
            color: #2d3436;
            font-weight: 700;
        }

        p {
            margin: 0;
            font-size: 16px;
            color: #636e72;
            line-height: 1.4;
        }

        .step-badge {
            background: #0984e3;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            vertical-align: middle;
            margin-right: 8px;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        button {
            background: #fff;
            border: 1px solid #b2bec3;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            transition: all 0.2s;
        }

        button:hover {
            background: #f1f2f6;
            transform: translateY(-2px);
        }

        button.primary {
            background: #0984e3;
            color: white;
            border: none;
        }

        button.next-level {
            background: #00b894;
            color: white;
            border: none;
            display: none;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        /* RTL */
        body.rtl {
            direction: rtl;
            font-family: 'Segoe UI', Tahoma, sans-serif;
        }

        body.rtl .instruction-card {
            border-left: none;
            border-right: 5px solid #0984e3;
        }

        body.rtl .step-badge {
            margin-right: 0;
            margin-left: 8px;
        }

        /* Success Overlay */
        #success-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.5);
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            opacity: 0;
            pointer-events: none;
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 100;
        }

        #success-overlay.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            pointer-events: auto;
        }
    </style>
</head>

<body>

    <div id="sim-wrapper">
        <canvas id="sim-canvas" width="1024" height="640"></canvas>

        <div id="ui-layer">
            <div class="ui-top-bar">
                <div class="instruction-card">
                    <h1><span class="step-badge" id="lvl-badge">M1</span> <span id="txt-title">La Nuit</span></h1>
                    <p id="txt-desc">Il fait nuit noire. Utilisez les 3 fils, la pile et la lampe pour vous √©clairer.
                    </p>
                </div>
                <div class="controls">
                    <button class="next-level" id="btn-next" onclick="app.startMission2()">Mission Suivante ‚ûî</button>
                    <button onclick="app.toggleLang()">FR / AR</button>
                    <button onclick="app.reset()">‚ü≥ Reset</button>
                </div>
            </div>

            <div id="success-overlay">
                <h1 style="color:#27ae60; font-size:40px;">Mission Termin√©e !</h1>
                <p style="font-size:20px; margin-top:10px;">Vous ma√Ætrisez le circuit √©lectrique.</p>
                <div style="font-size: 60px; margin-top:20px;">üèÜ</div>
            </div>
        </div>
    </div>

    <script>
        /**
         * CONSTANTES & CONFIG
         */
        const CONFIG = {
            w: 1024, h: 640,
            colors: {
                night: '#1e272e', // Fond Nuit
                day: '#ecf0f1',   // Fond Jour
                wire: '#e74c3c',
                copper: '#e67e22'
            },
            snapRadius: 20 // Rayon r√©duit pour √©viter les faux contacts
        };

        const TEXTS = {
            fr: {
                m1_title: "La Nuit",
                m1_desc: "Il fait nuit. Connectez la pile et la lampe pour avoir de la lumi√®re. Attention : Le (+) et le (-) ne doivent pas toucher le m√™me point !",
                m2_title_setup: "Le Jour",
                m2_desc_setup: "C'est le jour. Ajoutez l'interrupteur dans le circuit.",
                m2_title_night: "Fermer le circuit",
                m2_desc_night: "La nuit tombe... FERMEZ l'interrupteur pour allumer.",
                m2_title_day: "Ouvrir le circuit",
                m2_desc_day: "Le jour se l√®ve ! √âconomisez l'√©nergie : OUVREZ l'interrupteur.",
                next: "Mission 2 ‚ûî",
                finish_title: "Bravo !",
                finish_desc: "Simulation termin√©e avec succ√®s."
            },
            ar: {
                m1_title: "ÿßŸÑŸÑŸäŸÑ",
                m1_desc: "ÿßŸÑÿ¨Ÿà ŸÖÿ∏ŸÑŸÖ. ÿµŸÑ ÿßŸÑÿ®ÿ∑ÿßÿ±Ÿäÿ© ÿ®ÿßŸÑŸÖÿµÿ®ÿßÿ≠ ŸÑŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÑÿ∂Ÿàÿ°. ÿßŸÜÿ™ÿ®Ÿá: ŸÑÿß ÿ™ÿµŸÑ ÿßŸÑŸÖŸàÿ¨ÿ® ŸàÿßŸÑÿ≥ÿßŸÑÿ® ÿ®ŸÜŸÅÿ≥ ÿßŸÑŸÜŸÇÿ∑ÿ©!",
                m2_title_setup: "ÿßŸÑŸÜŸáÿßÿ±",
                m2_desc_setup: "ÿ•ŸÜŸá ÿßŸÑŸÜŸáÿßÿ±. ÿ£ÿ∂ŸÅ ÿßŸÑŸÇÿßÿ∑ÿπÿ© (ÿßŸÑŸÖŸÅÿ™ÿßÿ≠) ÿ•ŸÑŸâ ÿßŸÑÿØÿßÿ±ÿ©.",
                m2_title_night: "ÿ∫ŸÑŸÇ ÿßŸÑÿØÿßÿ±ÿ©",
                m2_desc_night: "ÿ≠ŸÑ ÿßŸÑŸÑŸäŸÑ... ÿ£ÿ∫ŸÑŸÇ ÿßŸÑŸÇÿßÿ∑ÿπÿ© ŸÑÿ•ÿ¥ÿπÿßŸÑ ÿßŸÑÿ∂Ÿàÿ°.",
                m2_title_day: "ŸÅÿ™ÿ≠ ÿßŸÑÿØÿßÿ±ÿ©",
                m2_desc_day: "ÿ∑ŸÑÿπ ÿßŸÑŸÜŸáÿßÿ±! ŸàŸÅÿ± ÿßŸÑÿ∑ÿßŸÇÿ©: ÿßŸÅÿ™ÿ≠ ÿßŸÑŸÇÿßÿ∑ÿπÿ©.",
                next: "ÿßŸÑŸÖŸáŸÖÿ© 2 ‚ûî",
                finish_title: "ÿ£ÿ≠ÿ≥ŸÜÿ™ !",
                finish_desc: "ÿ™ŸÖÿ™ ÿßŸÑŸÖÿ≠ÿßŸÉÿßÿ© ÿ®ŸÜÿ¨ÿßÿ≠."
            }
        };

        /**
         * CLASSES GRAPHIQUES
         */

        class Entity {
            constructor(x, y, w, h) {
                this.x = x; this.y = y; this.w = w; this.h = h;
                this.isDragging = false;
                this.draggable = true;
            }
            contains(mx, my) { return mx >= this.x && mx <= this.x + this.w && my >= this.y && my <= this.y + this.h; }
        }

        class Battery extends Entity {
            constructor(x, y) {
                super(x, y, 120, 150);
                this.terminals = [
                    { x: 20, y: -15, w: 15, h: 30, id: 'bat-' },
                    { x: 85, y: -15, w: 15, h: 30, id: 'bat+' }
                ];
            }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fillRect(5, 5, this.w, this.h);
                const g = ctx.createLinearGradient(0, 0, this.w, 0);
                g.addColorStop(0, '#2d3436'); g.addColorStop(0.5, '#636e72'); g.addColorStop(1, '#2d3436');
                ctx.fillStyle = g; ctx.fillRect(0, 0, this.w, this.h);
                ctx.fillStyle = '#f1c40f'; ctx.fillRect(10, 40, this.w - 20, 70);
                ctx.fillStyle = '#c0392b'; ctx.font = 'bold 24px sans-serif'; ctx.textAlign = 'center'; ctx.fillText('PILE', this.w / 2, 85);
                this.terminals.forEach((t, i) => {
                    ctx.fillStyle = '#bdc3c7'; ctx.fillRect(t.x, t.y, t.w, t.h);
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 28px sans-serif'; ctx.textAlign = 'center';
                    if (i === 0) ctx.fillText('-', t.x + t.w / 2, t.y + 60);
                    if (i === 1) ctx.fillText('+', t.x + t.w / 2, t.y + 60);

                    // Point de connexion visible
                    ctx.fillStyle = (i === 0) ? '#3498db' : '#e74c3c'; // Bleu pour -, Rouge pour +
                    ctx.beginPath(); ctx.arc(t.x + t.w / 2, t.y, 4, 0, Math.PI * 2); ctx.fill();
                });
                ctx.restore();
            }
            getTerminalPos(i) { return { x: this.x + this.terminals[i].x + 7, y: this.y, id: this.terminals[i].id }; }
        }

        class Lamp extends Entity {
            constructor(x, y) {
                super(x, y, 80, 150); // Hauteur augment√©e pour s√©parer visuellement
                this.isOn = false;
            }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y);

                // Socket (Culot)
                ctx.fillStyle = '#95a5a6'; ctx.fillRect(20, 90, 40, 30);

                // Bulb
                ctx.beginPath(); ctx.arc(40, 60, 35, 0, Math.PI * 2);
                if (this.isOn) {
                    ctx.fillStyle = '#f1c40f'; ctx.shadowColor = '#f1c40f'; ctx.shadowBlur = 50; ctx.fill(); ctx.shadowBlur = 0;
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 3; ctx.stroke();
                } else {
                    ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.strokeStyle = '#7f8c8d'; ctx.lineWidth = 1; ctx.fill(); ctx.stroke();
                }

                // Plot (Bas) - S√©par√© visuellement
                ctx.fillStyle = '#2d3436'; ctx.beginPath(); ctx.moveTo(30, 120); ctx.lineTo(50, 120); ctx.lineTo(40, 140); ctx.fill();
                ctx.fillStyle = '#bdc3c7'; ctx.beginPath(); ctx.arc(40, 143, 4, 0, Math.PI * 2); ctx.fill();

                // Points de connexion visibles
                // Culot
                ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(20, 105, 4, 0, Math.PI * 2); ctx.fill();
                // Plot
                ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(40, 143, 4, 0, Math.PI * 2); ctx.fill();

                ctx.restore();
            }
            getTerminalPos(i) {
                // S√©paration spatiale plus importante
                if (i === 0) return { x: this.x + 20, y: this.y + 105, id: 'lamp-side' }; // Cot√©
                return { x: this.x + 40, y: this.y + 143, id: 'lamp-bot' }; // Bas
            }
        }

        class Switch extends Entity {
            constructor(x, y) {
                super(x, y, 100, 60);
                this.isOpen = true;
            }
            toggle() { this.isOpen = !this.isOpen; }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.fillStyle = '#34495e'; ctx.beginPath(); ctx.roundRect(0, 10, 100, 40, 5); ctx.fill();
                ctx.fillStyle = '#f39c12';
                ctx.beginPath(); ctx.arc(15, 30, 8, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(85, 30, 8, 0, Math.PI * 2); ctx.fill();
                ctx.save(); ctx.translate(15, 30);
                const angle = this.isOpen ? -0.5 : 0; ctx.rotate(angle);
                ctx.fillStyle = '#bdc3c7'; ctx.fillRect(0, -6, 75, 12);
                ctx.fillStyle = '#c0392b'; ctx.beginPath(); ctx.arc(70, 0, 12, 0, Math.PI * 2); ctx.fill();
                ctx.restore(); ctx.restore();
            }
            hitTestLever(mx, my) {
                const leverX = this.isOpen ? 15 + Math.cos(-0.5) * 70 : 15 + 70;
                const leverY = this.isOpen ? 30 + Math.sin(-0.5) * 70 : 30;
                const dist = Math.hypot(mx - (this.x + leverX), my - (this.y + leverY));
                return dist < 25;
            }
            getTerminalPos(i) {
                if (i === 0) return { x: this.x + 15, y: this.y + 30, id: 'sw-left' };
                return { x: this.x + 85, y: this.y + 30, id: 'sw-right' };
            }
        }

        class Wire {
            constructor(x1, y1, x2, y2) {
                this.id = 'w' + Math.random().toString(36).substr(2, 5);
                this.p1 = { x: x1, y: y1, connectedTo: null };
                this.p2 = { x: x2, y: y2, connectedTo: null };
            }
            draw(ctx) {
                ctx.beginPath(); ctx.moveTo(this.p1.x, this.p1.y);
                const mx = (this.p1.x + this.p2.x) / 2; const my = (this.p1.y + this.p2.y) / 2 + 40;
                ctx.quadraticCurveTo(mx, my, this.p2.x, this.p2.y);
                ctx.strokeStyle = CONFIG.colors.wire; ctx.lineWidth = 6; ctx.lineCap = 'round'; ctx.stroke();
                ctx.fillStyle = CONFIG.colors.copper;
                ctx.beginPath(); ctx.arc(this.p1.x, this.p1.y, 5, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(this.p2.x, this.p2.y, 5, 0, Math.PI * 2); ctx.fill();
            }
            hitTestEndpoints(mx, my) {
                if (Math.hypot(mx - this.p1.x, my - this.p1.y) < 20) return 'p1';
                if (Math.hypot(mx - this.p2.x, my - this.p2.y) < 20) return 'p2';
                return null;
            }
            hitTestBody(mx, my) {
                const cx = (this.p1.x + this.p2.x) / 2; const cy = (this.p1.y + this.p2.y) / 2 + 20;
                return Math.hypot(mx - cx, my - cy) < 30;
            }
        }

        /**
         * MOTEUR DE JEU
         */
        class App {
            constructor() {
                this.canvas = document.getElementById('sim-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.wrapper = document.getElementById('sim-wrapper');
                this.state = 'M1'; this.isNight = true; this.lang = 'fr';
                this.components = []; this.wires = []; this.scale = 1;
                this.initM1(); this.bindEvents(); this.loop();
            }

            initM1() {
                this.state = 'M1'; this.isNight = true;
                this.components = []; this.wires = [];
                this.switchComp = null;

                this.battery = new Battery(100, 300);
                this.lamp = new Lamp(800, 300);
                this.components.push(this.battery, this.lamp);
                this.wires.push(new Wire(250, 400, 450, 400));
                this.wires.push(new Wire(480, 400, 680, 400));
                this.wires.push(new Wire(300, 500, 600, 500));
                this.updateUI(); this.updateAtmosphere();
            }

            startMission2() {
                this.state = 'M2_SETUP'; this.isNight = false;
                this.wires.forEach(w => { w.p1.connectedTo = null; w.p2.connectedTo = null; });
                this.switchComp = new Switch(460, 200);
                this.components.push(this.switchComp);
                document.getElementById('btn-next').style.display = 'none';
                this.updateUI(); this.updateAtmosphere();
            }

            updateAtmosphere() {
                this.wrapper.style.background = this.isNight ? CONFIG.colors.night : CONFIG.colors.day;
            }

            checkCircuit() {
                this.lamp.isOn = false;
                const adj = {};

                const addEdge = (id1, id2) => {
                    if (!adj[id1]) adj[id1] = []; if (!adj[id2]) adj[id2] = [];
                    adj[id1].push(id2); adj[id2].push(id1);
                };

                // 1. Fils
                this.wires.forEach(w => {
                    addEdge(w.id + '-p1', w.id + '-p2');
                    if (w.p1.connectedTo) addEdge(w.id + '-p1', w.p1.connectedTo);
                    if (w.p2.connectedTo) addEdge(w.id + '-p2', w.p2.connectedTo);
                });

                // 2. Composants Internes
                if (this.switchComp && !this.switchComp.isOpen) addEdge('sw-left', 'sw-right');

                // 3. CONTACTS DIRECTS
                const terminals = [];
                terminals.push(this.battery.getTerminalPos(0), this.battery.getTerminalPos(1));
                terminals.push(this.lamp.getTerminalPos(0), this.lamp.getTerminalPos(1));
                if (this.switchComp) terminals.push(this.switchComp.getTerminalPos(0), this.switchComp.getTerminalPos(1));

                for (let i = 0; i < terminals.length; i++) {
                    for (let j = i + 1; j < terminals.length; j++) {
                        const t1 = terminals[i]; const t2 = terminals[j];
                        // Seulement si c'est un vrai contact physique (distance tr√®s faible)
                        if (Math.hypot(t1.x - t2.x, t1.y - t2.y) < 25) {
                            addEdge(t1.id, t2.id);
                        }
                    }
                }

                // 4. Traversal depuis Bat+
                const visitedFromPlus = new Set();
                const stackP = ['bat+'];
                while (stackP.length > 0) {
                    const u = stackP.pop();
                    if (visitedFromPlus.has(u)) continue;
                    visitedFromPlus.add(u);
                    if (adj[u]) for (let v of adj[u]) stackP.push(v);
                }

                // 5. Traversal depuis Bat-
                const visitedFromMinus = new Set();
                const stackM = ['bat-'];
                while (stackM.length > 0) {
                    const u = stackM.pop();
                    if (visitedFromMinus.has(u)) continue;
                    visitedFromMinus.add(u);
                    if (adj[u]) for (let v of adj[u]) stackM.push(v);
                }

                // 6. Verification PHYSIQUE
                // Pour allumer, une borne de la lampe doit √™tre au (+) ET l'autre au (-)
                const sideAtPlus = visitedFromPlus.has('lamp-side');
                const botAtPlus = visitedFromPlus.has('lamp-bot');
                const sideAtMinus = visitedFromMinus.has('lamp-side');
                const botAtMinus = visitedFromMinus.has('lamp-bot');

                // Cas valide 1: Side au (+) et Bot au (-)
                // Cas valide 2: Bot au (+) et Side au (-)
                // Condition: Pas de "court-circuit local" o√π le meme pole touche les deux

                if ((sideAtPlus && botAtMinus) || (botAtPlus && sideAtMinus)) {
                    this.lamp.isOn = true;
                }

                this.checkMissionLogic();
            }

            checkMissionLogic() {
                if (this.state === 'M1') {
                    document.getElementById('btn-next').style.display = this.lamp.isOn ? 'block' : 'none';
                }
                else if (this.state === 'M2_SETUP') {
                    if (this.switchComp && this.switchComp.isOpen) {
                        const realState = this.switchComp.isOpen;
                        this.switchComp.isOpen = false;
                        this.checkCircuit();
                        const works = this.lamp.isOn;
                        this.switchComp.isOpen = realState;
                        this.lamp.isOn = false;

                        if (works) {
                            this.state = 'M2_NIGHT'; this.isNight = true;
                            this.updateAtmosphere(); this.updateUI();
                        }
                    }
                }
                else if (this.state === 'M2_NIGHT') {
                    if (this.lamp.isOn) {
                        setTimeout(() => {
                            if (this.state === 'M2_NIGHT') {
                                this.state = 'M2_DAY'; this.isNight = false;
                                this.updateAtmosphere(); this.updateUI();
                            }
                        }, 1000);
                    }
                }
                else if (this.state === 'M2_DAY') {
                    if (!this.lamp.isOn && this.switchComp.isOpen) {
                        this.state = 'FINISHED';
                        document.getElementById('success-overlay').classList.add('show');
                    }
                }
            }

            trySnap(point) {
                point.connectedTo = null;
                let best = CONFIG.snapRadius; let targetID = null; let snapX = null, snapY = null;

                const check = (t) => {
                    const d = Math.hypot(point.x - t.x, point.y - t.y);
                    if (d < best) { best = d; targetID = t.id; snapX = t.x; snapY = t.y; }
                };

                check(this.battery.getTerminalPos(0)); check(this.battery.getTerminalPos(1));
                check(this.lamp.getTerminalPos(0)); check(this.lamp.getTerminalPos(1));
                if (this.switchComp) { check(this.switchComp.getTerminalPos(0)); check(this.switchComp.getTerminalPos(1)); }

                this.wires.forEach(w => {
                    const d1 = Math.hypot(point.x - w.p1.x, point.y - w.p1.y);
                    if (d1 < best && d1 > 1) { best = d1; targetID = w.id + '-p1'; snapX = w.p1.x; snapY = w.p1.y; }
                    const d2 = Math.hypot(point.x - w.p2.x, point.y - w.p2.y);
                    if (d2 < best && d2 > 1) { best = d2; targetID = w.id + '-p2'; snapX = w.p2.x; snapY = w.p2.y; }
                });

                if (targetID) { point.x = snapX; point.y = snapY; point.connectedTo = targetID; }
            }

            bindEvents() {
                const getXY = e => {
                    const r = this.canvas.getBoundingClientRect();
                    return { x: (e.clientX - r.left) * (CONFIG.w / r.width), y: (e.clientY - r.top) * (CONFIG.h / r.height) };
                };

                const start = (e) => {
                    e.preventDefault();
                    const { x, y } = getXY(e.touches ? e.touches[0] : e);
                    if (this.switchComp && this.switchComp.hitTestLever(x, y)) { this.switchComp.toggle(); this.checkCircuit(); return; }
                    for (let w of this.wires) {
                        const hit = w.hitTestEndpoints(x, y);
                        if (hit) {
                            this.dragObj = w; this.dragMode = hit;
                            if (hit === 'p1') w.p1.connectedTo = null; else w.p2.connectedTo = null;
                            this.checkCircuit(); return;
                        }
                    }
                    for (let c of this.components) {
                        if (c.contains(x, y)) {
                            this.dragObj = c; this.dragMode = 'comp';
                            this.dragOffset = { x: x - c.x, y: y - c.y }; return;
                        }
                    }
                    for (let w of this.wires) {
                        if (w.hitTestBody(x, y)) {
                            this.dragObj = w; this.dragMode = 'wireBody';
                            this.dragOffset = { x: x - w.p1.x, y: y - w.p1.y }; return;
                        }
                    }
                };

                const move = (e) => {
                    e.preventDefault(); if (!this.dragObj) return;
                    const { x, y } = getXY(e.touches ? e.touches[0] : e);
                    if (this.dragMode === 'p1') { this.dragObj.p1.x = x; this.dragObj.p1.y = y; }
                    else if (this.dragMode === 'p2') { this.dragObj.p2.x = x; this.dragObj.p2.y = y; }
                    else if (this.dragMode === 'comp') {
                        this.dragObj.x = x - this.dragOffset.x; this.dragObj.y = y - this.dragOffset.y;
                        this.wires.forEach(w => {
                            const ids = this.dragObj instanceof Battery ? 'bat' : (this.dragObj instanceof Lamp ? 'lamp' : 'sw');
                            if (w.p1.connectedTo && w.p1.connectedTo.includes(ids)) w.p1.connectedTo = null;
                            if (w.p2.connectedTo && w.p2.connectedTo.includes(ids)) w.p2.connectedTo = null;
                        });
                        this.checkCircuit();
                    }
                    else if (this.dragMode === 'wireBody') {
                        const dx = x - this.dragOffset.x - this.dragObj.p1.x;
                        const dy = y - this.dragOffset.y - this.dragObj.p1.y;
                        this.dragObj.p1.x += dx; this.dragObj.p1.y += dy;
                        this.dragObj.p2.x += dx; this.dragObj.p2.y += dy;
                        this.dragObj.p1.connectedTo = null; this.dragObj.p2.connectedTo = null;
                        this.checkCircuit();
                    }
                };

                const end = (e) => {
                    if (!this.dragObj) return;
                    if (this.dragObj instanceof Wire) {
                        if (this.dragMode === 'p1' || this.dragMode === 'wireBody') this.trySnap(this.dragObj.p1);
                        if (this.dragMode === 'p2' || this.dragMode === 'wireBody') this.trySnap(this.dragObj.p2);
                        this.checkCircuit();
                    }
                    this.dragObj = null;
                };

                this.canvas.addEventListener('mousedown', start);
                window.addEventListener('mousemove', move);
                window.addEventListener('mouseup', end);
                this.canvas.addEventListener('touchstart', start, { passive: false });
                window.addEventListener('touchmove', move, { passive: false });
                window.addEventListener('touchend', end);
                window.addEventListener('resize', () => this.scaleToFit());
                this.scaleToFit();
            }

            scaleToFit() {
                // handled by global scaleToFit
            }

            loop() {
                this.ctx.clearRect(0, 0, CONFIG.w, CONFIG.h);
                this.components.forEach(c => c.draw(this.ctx));
                this.wires.forEach(w => w.draw(this.ctx));
                requestAnimationFrame(() => this.loop());
            }

            toggleLang() {
                this.lang = this.lang === 'fr' ? 'ar' : 'fr';
                document.body.classList.toggle('rtl', this.lang === 'ar');
                this.updateUI();
            }

            updateUI() {
                const t = TEXTS[this.lang];
                document.getElementById('lvl-badge').innerText = (this.state === 'M1') ? "1" : "2";
                let title = "", desc = "";
                if (this.state === 'M1') { title = t.m1_title; desc = t.m1_desc; }
                else if (this.state === 'M2_SETUP') { title = t.m2_title_setup; desc = t.m2_desc_setup; }
                else if (this.state === 'M2_NIGHT') { title = t.m2_title_night; desc = t.m2_desc_night; }
                else if (this.state === 'M2_DAY') { title = t.m2_title_day; desc = t.m2_desc_day; }
                document.getElementById('txt-title').innerText = title;
                document.getElementById('txt-desc').innerText = desc;
            }

            reset() { this.initM1(); document.getElementById('success-overlay').classList.remove('show'); }
        }

        const app = new App();

        // ---- Standard scaleToFit (CLAUDE.md) ----
        const DESIGN_W = 1024, DESIGN_H = 640;
        const wrapper = document.getElementById('sim-wrapper');
        let userZoom = 1, panX = 0, panY = 0;

        function scaleToFit() {
            const vw = window.innerWidth, vh = window.innerHeight;
            const baseScale = Math.min(vw / DESIGN_W, vh / DESIGN_H);
            const totalScale = baseScale * userZoom;
            wrapper.style.transform = 'translate(' + panX + 'px,' + panY + 'px) scale(' + totalScale + ')';
            wrapper.style.left = ((vw - DESIGN_W * baseScale) / 2) + 'px';
            wrapper.style.top = ((vh - DESIGN_H * baseScale) / 2) + 'px';
        }
        scaleToFit();
        window.addEventListener('resize', function () { userZoom = 1; panX = 0; panY = 0; scaleToFit(); });

        // ---- Pinch-to-zoom (mandatory) ----
        (function () {
            var pinching = false, lastDist = 0, lastMidX = 0, lastMidY = 0, lastTap = 0;
            document.addEventListener('touchstart', function (e) {
                if (e.touches.length === 2) {
                    e.preventDefault(); pinching = true;
                    var t1 = e.touches[0], t2 = e.touches[1];
                    lastDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                    lastMidX = (t1.clientX + t2.clientX) / 2;
                    lastMidY = (t1.clientY + t2.clientY) / 2;
                }
            }, { passive: false });
            document.addEventListener('touchmove', function (e) {
                if (!pinching || e.touches.length !== 2) return;
                e.preventDefault();
                var t1 = e.touches[0], t2 = e.touches[1];
                var dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                var midX = (t1.clientX + t2.clientX) / 2, midY = (t1.clientY + t2.clientY) / 2;
                var oldZoom = userZoom;
                userZoom = Math.max(1, Math.min(5, userZoom * (dist / lastDist)));
                var vw = window.innerWidth, vh = window.innerHeight;
                var baseScale = Math.min(vw / DESIGN_W, vh / DESIGN_H);
                var cx = (vw - DESIGN_W * baseScale) / 2, cy = (vh - DESIGN_H * baseScale) / 2;
                var ratio = userZoom / oldZoom;
                panX = panX * ratio + (1 - ratio) * (midX - cx);
                panY = panY * ratio + (1 - ratio) * (midY - cy);
                panX += midX - lastMidX; panY += midY - lastMidY;
                lastDist = dist; lastMidX = midX; lastMidY = midY;
                scaleToFit();
            }, { passive: false });
            document.addEventListener('touchend', function (e) {
                if (e.touches.length < 2) pinching = false;
                if (userZoom <= 1.05) { userZoom = 1; panX = 0; panY = 0; scaleToFit(); }
                if (e.touches.length === 0) {
                    var now = Date.now();
                    if (now - lastTap < 300 && userZoom > 1) { userZoom = 1; panX = 0; panY = 0; scaleToFit(); }
                    lastTap = now;
                }
            });
        })();

    </script>
</body>

</html>