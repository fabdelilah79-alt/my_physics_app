<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laboratoire Virtuel - Circuit √âlectrique Progressif</title>

    <style>
        /* --- RESET & BASE --- */
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            width: 100%;
            height: 100%;
            touch-action: none;
            font-family: system-ui, -apple-system, 'Segoe UI', sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }

        #sim-wrapper {
            width: 1024px;
            height: 640px;
            position: absolute;
            transform-origin: top left;
            background: linear-gradient(to bottom, #dfe6e9 0%, #b2bec3 100%);
            overflow: hidden;
        }

        /* Tapis de d√©coupe */
        #sim-wrapper::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: linear-gradient(rgba(0, 0, 0, 0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(0, 0, 0, 0.05) 1px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none;
        }

        canvas {
            display: block;
        }

        /* --- UI OVERLAY --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .ui-top-bar {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: auto;
            z-index: 10;
        }

        .instruction-card {
            background: #fff;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 50%;
            border-left: 4px solid #e17055;
            transition: all 0.3s;
        }

        h1 {
            margin: 0 0 5px 0;
            font-size: 20px;
            color: #2d3436;
            font-weight: 700;
        }

        p {
            margin: 0;
            font-size: 15px;
            color: #636e72;
        }

        .level-badge {
            display: inline-block;
            background: #2d3436;
            color: #fff;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
            vertical-align: middle;
            margin-right: 8px;
        }

        .btn-group {
            display: flex;
            gap: 10px;
        }

        button {
            background: #fff;
            border: 1px solid #b2bec3;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.2s;
        }

        button:hover {
            background: #f1f2f6;
        }

        button:active {
            transform: translateY(1px);
        }

        button.primary {
            background: #0984e3;
            color: white;
            border-color: #0984e3;
        }

        button.primary:hover {
            background: #74b9ff;
        }

        button.success {
            background: #00b894;
            color: white;
            border-color: #00b894;
            display: none;
        }

        button.success:hover {
            background: #55efc4;
        }

        /* RTL */
        body.rtl {
            direction: rtl;
            font-family: 'Segoe UI', Tahoma, sans-serif;
        }

        body.rtl .instruction-card {
            border-left: none;
            border-right: 4px solid #e17055;
        }

        body.rtl .level-badge {
            margin-right: 0;
            margin-left: 8px;
        }

        /* Success Overlay */
        #success-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: rgba(255, 255, 255, 0.95);
            padding: 30px 60px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
            opacity: 0;
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 100;
            border: 2px solid #2ecc71;
        }

        #success-overlay.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        #success-overlay h2 {
            margin: 0;
            color: #27ae60;
            font-size: 36px;
        }
    </style>
</head>

<body>

    <div id="sim-wrapper">
        <canvas id="sim-canvas" width="1024" height="640"></canvas>

        <div id="ui-layer">
            <div class="ui-top-bar">
                <div class="instruction-card">
                    <h1><span class="level-badge" id="lbl-level">Niv 1</span> <span id="txt-title">D√©fi : Lumi√®re
                            !</span></h1>
                    <p id="txt-desc">Utilisez les ciseaux et les fils pour allumer la lampe.</p>
                </div>
                <div class="btn-group">
                    <button class="success" onclick="app.nextLevel()" id="btn-next">Mission Suivante ‚ûî</button>
                    <button onclick="app.toggleLang()">FR / AR</button>
                    <button class="primary" onclick="app.reset()" id="btn-reset">Recommencer</button>
                </div>
            </div>

            <div id="success-overlay">
                <h2 id="txt-success">Bravo !</h2>
                <div style="font-size: 50px; margin-top:10px;">üí°‚ú®</div>
            </div>
        </div>
    </div>

    <script>

        const CONFIG = {
            w: 1024, h: 640,
            colors: { wireBody: '#e74c3c', wireCore: '#e67e22', shadow: 'rgba(0,0,0,0.3)' }
        };

        const TEXTS = {
            fr: {
                title1: "Couper et Connecter",
                desc1: "Coupez le fil avec les ciseaux et connectez la pile √† la lampe.",
                title2: "Contact Direct",
                desc2: "Sans ciseaux ! Posez la lampe sur la pile et utilisez le fil restant pour fermer le circuit.",
                success: "Lumi√®re !",
                reset: "Reset",
                next: "Niveau Suivant ‚ûî",
                level: "Niveau"
            },
            ar: {
                title1: "ŸÇÿµ Ÿàÿ™ŸàÿµŸäŸÑ",
                desc1: "ÿßŸÇÿ∑ÿπ ÿßŸÑÿ≥ŸÑŸÉ ÿ®ÿßŸÑŸÖŸÇÿµ ŸàŸÇŸÖ ÿ®ÿ™ŸàÿµŸäŸÑ ÿßŸÑÿ®ÿ∑ÿßÿ±Ÿäÿ© ÿ®ÿßŸÑŸÖÿµÿ®ÿßÿ≠.",
                title2: "ÿ™ŸàÿµŸäŸÑ ŸÖÿ®ÿßÿ¥ÿ±",
                desc2: "ÿ®ÿØŸàŸÜ ŸÖŸÇÿµ! ÿ∂ÿπ ÿßŸÑŸÖÿµÿ®ÿßÿ≠ ÿπŸÑŸâ ÿßŸÑÿ®ÿ∑ÿßÿ±Ÿäÿ© Ÿàÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ≥ŸÑŸÉ ŸÑÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑÿØÿßÿ±ÿ©.",
                success: "ÿ£ÿ≠ÿ≥ŸÜÿ™ !",
                reset: "ÿ•ÿπÿßÿØÿ©",
                next: "ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ™ÿßŸÑŸä ‚ûî",
                level: "ŸÖÿ≥ÿ™ŸàŸâ"
            }
        };

        /* --- CLASSES GRAPHIQUES --- */

        function drawShadow(ctx, x, y, w, h, blur = 15) {
            ctx.save(); ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.filter = `blur(${blur}px)`;
            ctx.fillRect(x + 5, y + 5, w, h); ctx.restore();
        }

        class Entity {
            constructor(x, y, w, h) {
                this.x = x; this.y = y; this.w = w; this.h = h;
                this.isDragging = false;
                this.draggable = false; // Par d√©faut, objets fixes
            }
            contains(mx, my) {
                return mx >= this.x && mx <= this.x + this.w && my >= this.y && my <= this.y + this.h;
            }
        }

        class Battery extends Entity {
            constructor(x, y) {
                super(x, y, 130, 160);
                this.terminals = [
                    { x: 25, y: -20, w: 15, h: 40, label: '-', id: 'bat-', color: '#95a5a6' },
                    { x: 90, y: -20, w: 15, h: 40, label: '+', id: 'bat+', color: '#95a5a6' } // Longue
                ];
            }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y);
                drawShadow(ctx, 5, 5, this.w - 10, this.h - 10, 20);
                // Corps
                const grad = ctx.createLinearGradient(0, 0, this.w, 0);
                grad.addColorStop(0, '#2d3436'); grad.addColorStop(0.5, '#2d3436'); grad.addColorStop(1, '#000000');
                ctx.fillStyle = grad; ctx.beginPath(); ctx.roundRect(0, 0, this.w, this.h, 10); ctx.fill();
                // Sticker
                ctx.fillStyle = '#f1c40f'; ctx.fillRect(10, 30, this.w - 20, 90);
                ctx.fillStyle = '#c0392b'; ctx.font = 'bold 28px Roboto'; ctx.textAlign = 'center'; ctx.fillText('PILE', this.w / 2, 65);
                ctx.fillStyle = '#000'; ctx.font = 'bold 20px Roboto'; ctx.fillText('4.5V', this.w / 2, 95);
                // Terminaux
                this.terminals.forEach(t => {
                    const tGrad = ctx.createLinearGradient(t.x, 0, t.x + t.w, 0);
                    tGrad.addColorStop(0, '#bdc3c7'); tGrad.addColorStop(0.5, '#fff'); tGrad.addColorStop(1, '#bdc3c7');
                    ctx.fillStyle = tGrad; ctx.fillRect(t.x, t.y, t.w, t.h);
                    ctx.fillStyle = '#2d3436'; ctx.font = 'bold 18px monospace'; ctx.fillText(t.label, t.x + t.w / 2, t.y + 20);
                });
                ctx.restore();
            }
            getTerminalPos(index) {
                const t = this.terminals[index];
                return { x: this.x + t.x + t.w / 2, y: this.y + t.y + 5, id: t.id, parent: this };
            }
            // Zone de contact physique pour la mission 2
            getTerminalRect(index) {
                const t = this.terminals[index];
                return { x: this.x + t.x, y: this.y + t.y, w: t.w, h: t.h };
            }
        }

        class Lamp extends Entity {
            constructor(x, y) {
                super(x, y, 100, 160);
                this.isOn = false;
                // D√©calages relatifs des terminaux
                this.tOffsets = [{ x: 50, y: 110 }, { x: 50, y: 155 }];
            }

            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y);

                // Ombre (plus petite si drag)
                if (!this.isDragging) {
                    ctx.save(); ctx.translate(50, 160); ctx.scale(1, 0.3);
                    ctx.beginPath(); ctx.arc(0, 0, 30, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.filter = 'blur(6px)'; ctx.fill();
                    ctx.restore();
                }

                // 1. Plot (Pointe)
                ctx.fillStyle = '#2d3436';
                ctx.beginPath(); ctx.moveTo(35, 130); ctx.lineTo(65, 130); ctx.lineTo(60, 145); ctx.lineTo(40, 145); ctx.fill();
                ctx.fillStyle = '#b2bec3'; ctx.beginPath(); ctx.arc(50, 148, 6, 0, Math.PI * 2); ctx.fill();

                // 2. Culot (Vis)
                const metalGrad = ctx.createLinearGradient(30, 0, 70, 0);
                metalGrad.addColorStop(0, '#95a5a6'); metalGrad.addColorStop(0.5, '#fff'); metalGrad.addColorStop(1, '#7f8c8d');
                ctx.fillStyle = metalGrad; ctx.fillRect(30, 90, 40, 40);
                ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(30, 100); ctx.lineTo(70, 95); ctx.moveTo(30, 110); ctx.lineTo(70, 105); ctx.stroke();

                // 3. Verre
                ctx.beginPath(); ctx.arc(50, 50, 40, 0, Math.PI * 2);
                if (this.isOn) {
                    const lightGrad = ctx.createRadialGradient(50, 50, 10, 50, 50, 60);
                    lightGrad.addColorStop(0, '#fff'); lightGrad.addColorStop(0.4, '#feca57'); lightGrad.addColorStop(1, 'rgba(254, 202, 87, 0)');
                    ctx.fillStyle = lightGrad; ctx.globalCompositeOperation = 'lighter'; ctx.fill(); ctx.globalCompositeOperation = 'source-over';
                    ctx.shadowColor = '#ff9f43'; ctx.shadowBlur = 80; ctx.strokeStyle = 'rgba(255,255,255,0.8)'; ctx.stroke();
                } else {
                    const glassGrad = ctx.createRadialGradient(40, 40, 5, 50, 50, 40);
                    glassGrad.addColorStop(0, 'rgba(255,255,255,0.8)'); glassGrad.addColorStop(1, 'rgba(200,200,200,0.1)');
                    ctx.fillStyle = glassGrad; ctx.fill(); ctx.shadowBlur = 0; ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 1; ctx.stroke();
                }

                // Filament
                ctx.beginPath(); ctx.moveTo(42, 90); ctx.lineTo(42, 50); ctx.lineTo(58, 50); ctx.lineTo(58, 90);
                ctx.strokeStyle = this.isOn ? '#fff' : '#7f8c8d'; ctx.lineWidth = this.isOn ? 3 : 1; ctx.stroke();

                if (this.isOn) { ctx.shadowColor = '#fff'; ctx.shadowBlur = 10; }
                ctx.beginPath(); ctx.moveTo(42, 50); ctx.bezierCurveTo(45, 30, 55, 30, 58, 50); ctx.stroke();
                ctx.shadowBlur = 0;

                ctx.restore();
            }

            getTerminalPos(index) {
                if (index === 0) return { x: this.x + 30, y: this.y + 110, id: 'lamp-side', parent: this }; // C√¥t√©
                if (index === 1) return { x: this.x + 50, y: this.y + 155, id: 'lamp-bot', parent: this };  // Plot
            }
        }

        class Scissors extends Entity {
            constructor(x, y) {
                super(x, y, 100, 100);
                this.angle = 0.2;
                this.draggable = true;
            }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.rotate(this.isDragging ? -0.1 : 0);
                // Ombre
                ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.filter = 'blur(5px)';
                ctx.beginPath(); ctx.ellipse(50, 60, 40, 15, -0.5, 0, Math.PI * 2); ctx.fill(); ctx.filter = 'none';

                this.drawBlade(ctx, false);
                this.drawBlade(ctx, true);
                ctx.fillStyle = '#7f8c8d'; ctx.beginPath(); ctx.arc(50, 50, 4, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            }
            drawBlade(ctx, isTop) {
                ctx.save(); ctx.translate(50, 50);
                ctx.rotate(isTop ? -this.angle : this.angle);
                const bladeGrad = ctx.createLinearGradient(0, 0, 80, 0);
                bladeGrad.addColorStop(0, '#bdc3c7'); bladeGrad.addColorStop(1, '#95a5a6');
                ctx.fillStyle = bladeGrad;
                ctx.beginPath();
                if (isTop) { ctx.moveTo(0, 0); ctx.lineTo(80, 0); ctx.lineTo(80, 15); ctx.lineTo(0, 15); }
                else { ctx.moveTo(0, 0); ctx.lineTo(80, 0); ctx.lineTo(80, -15); ctx.lineTo(0, -15); }
                ctx.fill();
                ctx.fillStyle = '#d63031';
                ctx.beginPath();
                if (isTop) { ctx.arc(-20, 10, 20, 0, Math.PI * 2); ctx.rect(-20, 0, 20, 15); }
                else { ctx.arc(-20, -10, 20, 0, Math.PI * 2); ctx.rect(-20, -15, 20, 15); }
                ctx.fill();
                ctx.globalCompositeOperation = 'destination-out'; ctx.fillStyle = '#000';
                ctx.beginPath(); ctx.arc(-22, isTop ? 10 : -10, 8, 0, Math.PI * 2); ctx.fill();
                ctx.globalCompositeOperation = 'source-over';
                ctx.restore();
            }
            getCutPoint() { return { x: this.x + 90, y: this.y + 50 }; }
        }

        class Wire {
            constructor(x1, y1, x2, y2) {
                this.p1 = { x: x1, y: y1, connectedTo: null };
                this.p2 = { x: x2, y: y2, connectedTo: null };
            }
            draw(ctx) {
                const dx = this.p2.x - this.p1.x; const dy = this.p2.y - this.p1.y;
                const dist = Math.hypot(dx, dy);
                const slack = Math.max(0, 300 - dist) * 0.4;
                const cpX = (this.p1.x + this.p2.x) / 2;
                const cpY = (this.p1.y + this.p2.y) / 2 + slack + 20;

                ctx.beginPath(); ctx.moveTo(this.p1.x, this.p1.y); ctx.quadraticCurveTo(cpX, cpY, this.p2.x, this.p2.y);
                ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 10; ctx.stroke(); // Ombre
                ctx.strokeStyle = CONFIG.colors.wireBody; ctx.lineWidth = 6; ctx.lineCap = 'round'; ctx.stroke();
                ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 2; ctx.stroke(); // Reflet

                this.drawStrippedEnd(ctx, this.p1); this.drawStrippedEnd(ctx, this.p2);
            }
            drawStrippedEnd(ctx, p) {
                ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, Math.PI * 2); ctx.fillStyle = CONFIG.colors.wireCore; ctx.fill();
            }
            hitTestEndpoints(mx, my) {
                if (Math.hypot(mx - this.p1.x, my - this.p1.y) < 20) return 'p1';
                if (Math.hypot(mx - this.p2.x, my - this.p2.y) < 20) return 'p2';
                return null;
            }
            hitTestBody(mx, my) {
                const minX = Math.min(this.p1.x, this.p2.x) - 20; const maxX = Math.max(this.p1.x, this.p2.x) + 20;
                const minY = Math.min(this.p1.y, this.p2.y) - 20; const maxY = Math.max(this.p1.y, this.p2.y) + 150;
                return (mx > minX && mx < maxX && my > minY && my < maxY);
            }
        }

        /* --- MOTEUR APP --- */

        class Application {
            constructor() {
                this.canvas = document.getElementById('sim-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.wrapper = document.getElementById('sim-wrapper');

                this.lang = 'fr';
                this.mission = 1; // Niveau 1 ou 2

                this.entities = [];
                this.wires = [];
                this.scale = 1; this.baseScale = 1;

                this.init();
                this.bindEvents();
                this.gameLoop();
            }

            init() {
                this.wires = [];
                this.entities = [];
                this.scissors = null; // IMPORTANT: R√©initialiser les ciseaux pour la Mission 2

                this.battery = new Battery(80, 250);
                this.lamp = new Lamp(800, 250);

                if (this.mission === 1) {
                    this.scissors = new Scissors(450, 80);
                    this.entities.push(this.battery, this.lamp, this.scissors);
                    // Fil initial tr√®s long √† couper
                    this.wires.push(new Wire(200, 450, 700, 450));
                    this.lamp.draggable = false; // Lampe fixe en mission 1
                } else {
                    // Mission 2: Pas de ciseaux
                    this.entities.push(this.battery, this.lamp);
                    // Un seul fil (d√©j√† coup√© ou fourni)
                    this.wires.push(new Wire(200, 450, 600, 450));
                    this.lamp.draggable = true; // Lampe mobile
                }

                this.updateUI();
                document.getElementById('success-overlay').classList.remove('show');
                document.getElementById('btn-next').style.display = 'none';
            }

            checkCircuit() {
                this.lamp.isOn = false;

                // --- DETECTION CONTACT PHYSIQUE (Mission 2) ---
                // On regarde si le plot ou le culot de la lampe touche une borne pile
                let directContact = { plus: null, minus: null }; // Stocke l'ID du terminal lampe qui touche

                // Bornes de la pile
                const batPlusRect = this.battery.getTerminalRect(1);
                const batMinusRect = this.battery.getTerminalRect(0);

                // Terminaux de la lampe (Positions globales)
                const lampSide = this.lamp.getTerminalPos(0);
                const lampBot = this.lamp.getTerminalPos(1);

                const checkOverlap = (pt, rect) => {
                    return (pt.x > rect.x && pt.x < rect.x + rect.w && pt.y > rect.y && pt.y < rect.y + rect.h + 10);
                };

                if (checkOverlap(lampBot, batPlusRect)) directContact.plus = 'lamp-bot';
                if (checkOverlap(lampSide, batPlusRect)) directContact.plus = 'lamp-side';
                if (checkOverlap(lampBot, batMinusRect)) directContact.minus = 'lamp-bot';
                if (checkOverlap(lampSide, batMinusRect)) directContact.minus = 'lamp-side';

                // --- GRAPH TRAVERSAL ---
                // On construit le graphe des connexions filaires
                const connections = {};
                const registerConn = (id, wire) => {
                    if (!connections[id]) connections[id] = [];
                    connections[id].push(wire);
                }
                this.wires.forEach(w => {
                    if (w.p1.connectedTo) registerConn(w.p1.connectedTo, w);
                    if (w.p2.connectedTo) registerConn(w.p2.connectedTo, w);
                });

                // Fonction pour voir ce qui est connect√© √©lectriquement √† un point de d√©part
                const getConnectedGroup = (startIds) => {
                    let reached = new Set(startIds); // Commence avec les points de contact directs
                    let queue = [...startIds];
                    let visitedWires = new Set();

                    while (queue.length > 0) {
                        let curr = queue.pop();
                        let wiresHere = connections[curr] || [];
                        wiresHere.forEach(w => {
                            if (!visitedWires.has(w)) {
                                visitedWires.add(w);
                                let otherEnd = (w.p1.connectedTo === curr) ? w.p2.connectedTo : w.p1.connectedTo;
                                if (otherEnd && !reached.has(otherEnd)) {
                                    reached.add(otherEnd);
                                    queue.push(otherEnd);
                                }
                            }
                        });
                    }
                    return reached;
                };

                // Analyse Finale :
                // Le pole PLUS de la pile 'touche' quoi ? (Soit par fil 'bat+', soit par contact direct)
                let plusSources = ['bat+'];
                // Le pole MOINS 'touche' quoi ?
                let minusSources = ['bat-'];

                const reachedFromPlus = getConnectedGroup(plusSources);
                const reachedFromMinus = getConnectedGroup(minusSources);

                // Est-ce que le cot√© PLUS atteint une borne lampe ?
                let plusToLampSide = reachedFromPlus.has('lamp-side') || directContact.plus === 'lamp-side';
                let plusToLampBot = reachedFromPlus.has('lamp-bot') || directContact.plus === 'lamp-bot';

                // Est-ce que le cot√© MOINS atteint une borne lampe ?
                let minusToLampSide = reachedFromMinus.has('lamp-side') || directContact.minus === 'lamp-side';
                let minusToLampBot = reachedFromMinus.has('lamp-bot') || directContact.minus === 'lamp-bot';

                // SUCCESS : La lampe est travers√©e si le + touche un bout et le - touche l'autre
                let success = (plusToLampSide && minusToLampBot) || (plusToLampBot && minusToLampSide);

                if (success) {
                    this.lamp.isOn = true;
                    document.getElementById('success-overlay').classList.add('show');
                    // Si Mission 1, afficher le bouton suivant
                    if (this.mission === 1) {
                        document.getElementById('btn-next').style.display = 'block';
                    }
                }
            }

            tryCutWire() {
                if (!this.scissors) return;
                const cutPt = this.scissors.getCutPoint();
                for (let i = 0; i < this.wires.length; i++) {
                    const w = this.wires[i];
                    const midX = (w.p1.x + w.p2.x) / 2;
                    const midY = (w.p1.y + w.p2.y) / 2 + 50;
                    if (Math.hypot(cutPt.x - midX, cutPt.y - midY) < 50) {
                        const w1 = new Wire(w.p1.x, w.p1.y, midX - 30, midY); w1.p1.connectedTo = w.p1.connectedTo;
                        const w2 = new Wire(midX + 30, midY, w.p2.x, w.p2.y); w2.p2.connectedTo = w.p2.connectedTo;
                        this.wires.splice(i, 1, w1, w2);
                        this.scissors.angle = 0.5; setTimeout(() => this.scissors.angle = 0.2, 150);
                        break;
                    }
                }
            }

            trySnapWire(point) {
                point.connectedTo = null;
                let bestDist = 40; let snapT = null;
                const allTerminals = [
                    this.battery.getTerminalPos(0), this.battery.getTerminalPos(1),
                    this.lamp.getTerminalPos(0), this.lamp.getTerminalPos(1)
                ];
                allTerminals.forEach(t => {
                    const d = Math.hypot(point.x - t.x, point.y - t.y);
                    if (d < bestDist) { bestDist = d; snapT = t; }
                });
                if (snapT) { point.x = snapT.x; point.y = snapT.y; point.connectedTo = snapT.id; }
            }

            // --- INPUT ---

            getCoords(e) {
                const r = this.canvas.getBoundingClientRect();
                return { x: (e.clientX - r.left) * (this.canvas.width / r.width), y: (e.clientY - r.top) * (this.canvas.height / r.height) };
            }

            bindEvents() {
                const start = (x, y) => {
                    // 1. Fils
                    for (let w of this.wires) {
                        const hit = w.hitTestEndpoints(x, y);
                        if (hit) {
                            this.dragTarget = w; this.dragMode = hit;
                            if (hit === 'p1') w.p1.connectedTo = null; else w.p2.connectedTo = null;
                            this.checkCircuit(); return;
                        }
                    }
                    // 2. Entit√©s (Ciseaux ou Lampe)
                    for (let e of this.entities) {
                        if (e.draggable && e.contains(x, y)) {
                            this.dragTarget = e; this.dragMode = 'entity';
                            this.dragOffset = { x: x - e.x, y: y - e.y };
                            e.isDragging = true;
                            // D√©connecter fils si lampe bouge
                            if (e instanceof Lamp) {
                                this.wires.forEach(w => {
                                    if (w.p1.connectedTo && w.p1.connectedTo.startsWith('lamp')) w.p1.connectedTo = null;
                                    if (w.p2.connectedTo && w.p2.connectedTo.startsWith('lamp')) w.p2.connectedTo = null;
                                });
                                this.checkCircuit();
                            }
                            return;
                        }
                    }
                    // 3. Corps fil
                    for (let w of this.wires) {
                        if (w.hitTestBody(x, y)) {
                            this.dragTarget = w; this.dragMode = 'body';
                            this.dragOffset = { x: x - w.p1.x, y: y - w.p1.y };
                            return;
                        }
                    }
                };

                const move = (x, y) => {
                    if (!this.dragTarget) return;
                    if (this.dragMode === 'p1') { this.dragTarget.p1.x = x; this.dragTarget.p1.y = y; }
                    else if (this.dragMode === 'p2') { this.dragTarget.p2.x = x; this.dragTarget.p2.y = y; }
                    else if (this.dragMode === 'entity') {
                        this.dragTarget.x = x - this.dragOffset.x; this.dragTarget.y = y - this.dragOffset.y;
                        if (this.dragTarget instanceof Lamp) this.checkCircuit(); // Check temps r√©el
                    }
                    else if (this.dragMode === 'body') {
                        const w = this.dragTarget; const dx = x - this.dragOffset.x - w.p1.x; const dy = y - this.dragOffset.y - w.p1.y;
                        w.p1.x += dx; w.p1.y += dy; w.p2.x += dx; w.p2.y += dy;
                        w.p1.connectedTo = null; w.p2.connectedTo = null;
                        this.checkCircuit();
                    }
                };

                const end = () => {
                    if (!this.dragTarget) return;
                    if (this.dragTarget instanceof Scissors) { this.dragTarget.isDragging = false; this.tryCutWire(); }
                    else if (this.dragTarget instanceof Lamp) { this.dragTarget.isDragging = false; this.checkCircuit(); }
                    else if (this.dragTarget instanceof Wire) {
                        if (this.dragMode === 'p1' || this.dragMode === 'body') this.trySnapWire(this.dragTarget.p1);
                        if (this.dragMode === 'p2' || this.dragMode === 'body') this.trySnapWire(this.dragTarget.p2);
                        this.checkCircuit();
                    }
                    this.dragTarget = null;
                };

                this.canvas.addEventListener('mousedown', e => start(this.getCoords(e).x, this.getCoords(e).y));
                window.addEventListener('mousemove', e => move(this.getCoords(e).x, this.getCoords(e).y));
                window.addEventListener('mouseup', end);
                this.canvas.addEventListener('touchstart', e => { if (e.touches.length === 1) { e.preventDefault(); start(this.getCoords(e.touches[0]).x, this.getCoords(e.touches[0]).y); } }, { passive: false });
                this.canvas.addEventListener('touchmove', e => { if (e.touches.length === 1) { e.preventDefault(); move(this.getCoords(e.touches[0]).x, this.getCoords(e.touches[0]).y); } }, { passive: false });
                window.addEventListener('touchend', end);
            }

            gameLoop() {
                this.ctx.clearRect(0, 0, CONFIG.w, CONFIG.h);

                // Ordre de dessin: Pile toujours derri√®re pour que la Lampe passe "devant" ou "dessus"
                this.battery.draw(this.ctx);
                // Si la lampe est sur la pile, elle doit √™tre dessin√©e apr√®s
                this.lamp.draw(this.ctx);

                this.wires.forEach(w => w.draw(this.ctx));
                if (this.scissors) this.scissors.draw(this.ctx);

                requestAnimationFrame(() => this.gameLoop());
            }

            toggleLang() {
                this.lang = (this.lang === 'fr') ? 'ar' : 'fr';
                document.body.classList.toggle('rtl', this.lang === 'ar');
                this.updateUI();
            }

            nextLevel() {
                this.mission = 2;
                this.init();
            }

            updateUI() {
                const t = TEXTS[this.lang];
                document.getElementById('lbl-level').innerText = t.level + " " + this.mission;
                document.getElementById('txt-title').innerText = (this.mission === 1) ? t.title1 : t.title2;
                document.getElementById('txt-desc').innerText = (this.mission === 1) ? t.desc1 : t.desc2;
                document.getElementById('txt-success').innerText = t.success;
                document.getElementById('btn-reset').innerText = t.reset;
                document.getElementById('btn-next').innerText = t.next;
            }

            reset() { this.init(); }
        }

        const app = new Application();

        // ---- Standard scaleToFit (CLAUDE.md) ----
        const DESIGN_W = 1024, DESIGN_H = 640;
        const wrapper = document.getElementById('sim-wrapper');
        let userZoom = 1, panX = 0, panY = 0;

        function scaleToFit() {
            const vw = window.innerWidth, vh = window.innerHeight;
            const baseScale = Math.min(vw / DESIGN_W, vh / DESIGN_H);
            const totalScale = baseScale * userZoom;
            wrapper.style.transform = 'translate(' + panX + 'px,' + panY + 'px) scale(' + totalScale + ')';
            wrapper.style.left = ((vw - DESIGN_W * baseScale) / 2) + 'px';
            wrapper.style.top = ((vh - DESIGN_H * baseScale) / 2) + 'px';
        }
        scaleToFit();
        window.addEventListener('resize', function () { userZoom = 1; panX = 0; panY = 0; scaleToFit(); });

        // ---- Pinch-to-zoom (mandatory) ----
        (function () {
            var pinching = false, lastDist = 0, lastMidX = 0, lastMidY = 0, lastTap = 0;
            document.addEventListener('touchstart', function (e) {
                if (e.touches.length === 2) {
                    e.preventDefault(); pinching = true;
                    var t1 = e.touches[0], t2 = e.touches[1];
                    lastDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                    lastMidX = (t1.clientX + t2.clientX) / 2;
                    lastMidY = (t1.clientY + t2.clientY) / 2;
                }
            }, { passive: false });
            document.addEventListener('touchmove', function (e) {
                if (!pinching || e.touches.length !== 2) return;
                e.preventDefault();
                var t1 = e.touches[0], t2 = e.touches[1];
                var dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                var midX = (t1.clientX + t2.clientX) / 2, midY = (t1.clientY + t2.clientY) / 2;
                var oldZoom = userZoom;
                userZoom = Math.max(1, Math.min(5, userZoom * (dist / lastDist)));
                var vw = window.innerWidth, vh = window.innerHeight;
                var baseScale = Math.min(vw / DESIGN_W, vh / DESIGN_H);
                var cx = (vw - DESIGN_W * baseScale) / 2, cy = (vh - DESIGN_H * baseScale) / 2;
                var ratio = userZoom / oldZoom;
                panX = panX * ratio + (1 - ratio) * (midX - cx);
                panY = panY * ratio + (1 - ratio) * (midY - cy);
                panX += midX - lastMidX; panY += midY - lastMidY;
                lastDist = dist; lastMidX = midX; lastMidY = midY;
                scaleToFit();
            }, { passive: false });
            document.addEventListener('touchend', function (e) {
                if (e.touches.length < 2) pinching = false;
                if (userZoom <= 1.05) { userZoom = 1; panX = 0; panY = 0; scaleToFit(); }
                if (e.touches.length === 0) {
                    var now = Date.now();
                    if (now - lastTap < 300 && userZoom > 1) { userZoom = 1; panX = 0; panY = 0; scaleToFit(); }
                    lastTap = now;
                }
            });
        })();

    </script>
</body>

</html>