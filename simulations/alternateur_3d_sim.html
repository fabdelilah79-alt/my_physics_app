<!DOCTYPE html>
<html lang="fr" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulation Alternateur 3D | محاكاة المولد الكهربائي ثلاثي الأبعاد</title>
    <style>
        html, body { margin: 0; overflow: hidden; background: #000; width: 100%; height: 100%; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* === FIXED DESIGN SIZE === */
        #sim-wrapper {
            width: 1024px;
            height: 640px;
            position: absolute;
            transform-origin: top left;
            overflow: hidden;
            display: flex;
            background-color: #2c3e50;
        }

        /* Container pour la 3D */
        #canvas-container {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            background-color: #87CEEB;
        }

        /* Barre latérale de commande */
        #sidebar {
            width: 260px;
            box-sizing: border-box;
            background-color: #f4f4f4;
            display: flex;
            flex-direction: column;
            padding: 15px;
            box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            z-index: 20;
            overflow-y: auto;
        }

        h2 {
            margin-top: 0;
            color: #2c3e50;
            font-size: 1.2rem;
            text-align: center;
            border-bottom: 2px solid #ddd;
            padding-bottom: 10px;
        }

        .control-section {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        h3 { margin: 0 0 10px 0; font-size: 0.9rem; color: #7f8c8d; text-transform: uppercase; letter-spacing: 1px; font-weight: 700; }

        .btn-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }

        button {
            padding: 12px;
            font-size: 14px;
            cursor: pointer;
            border: none;
            border-radius: 6px;
            background-color: #ecf0f1;
            color: #2c3e50;
            transition: all 0.2s;
            font-weight: 600;
            text-align: left;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        button:hover { background-color: #dfe6e9; }
        
        button.active {
            color: white;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        /* Couleurs spécifiques boutons actifs */
        #btn-wind.active { background-color: #27ae60; }
        #btn-hydro.active { background-color: #2980b9; }
        #btn-steam.active { background-color: #d35400; }

        #btn-toggle {
            background-color: #f1c40f;
            color: #333;
            width: 100%;
            text-align: center;
            justify-content: center;
            font-size: 1.1rem;
        }
        
        #btn-internals {
            background-color: #8e44ad;
            color: white;
            width: 100%;
            justify-content: center;
        }

        /* Power Meter */
        #power-meter {
            width: 100%;
            height: 15px;
            background: #dfe6e9;
            border-radius: 10px;
            margin-top: 10px;
            overflow: hidden;
            border: 1px solid #bdc3c7;
        }
        #power-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #f1c40f, #e67e22);
            transition: width 0.1s linear;
        }

        .status-led {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ccc;
            display: inline-block;
        }
        button.active .status-led { background: white; }

        #instructions {
            font-size: 0.85rem;
            color: #7f8c8d;
            line-height: 1.4;
            background: #fff;
            padding: 10px;
            border-radius: 6px;
            border-left: 4px solid #3498db;
        }

        /* No responsive breakpoints needed — fixed design scales to fit */

        /* Language Switcher */
        #btn-lang {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #3498db;
            border-radius: 6px;
            padding: 8px 16px;
            cursor: pointer;
            font-weight: 600;
            color: #2c3e50;
            z-index: 100;
            transition: all 0.2s;
        }
        #btn-lang:hover {
            background: #3498db;
            color: white;
        }

        /* RTL Support */
        html[dir="rtl"] #sidebar {
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
        }
        html[dir="rtl"] #btn-lang {
            right: auto;
            left: 15px;
        }
        html[dir="rtl"] button {
            text-align: right;
        }

        /* 3D Labels */
        .label-3d {
            position: absolute;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 600;
            pointer-events: none;
            transform: translate(-50%, -50%);
            white-space: nowrap;
            border: 1px solid rgba(255, 255, 255, 0.3);
            z-index: 10;
        }
        .label-3d.highlight {
            background: rgba(52, 152, 219, 0.9);
            border-color: rgba(255, 255, 255, 0.8);
        }

        /* Fullscreen Button */
        #btn-fullscreen {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #2ecc71;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-weight: 600;
            color: #2c3e50;
            z-index: 100;
            transition: all 0.2s;
        }
        #btn-fullscreen:hover {
            background: #2ecc71;
            color: white;
        }
        html[dir="rtl"] #btn-fullscreen {
            left: auto;
            right: 15px;
        }

        /* Fullscreen handled by scaleToFit() — no extra CSS needed */
    </style>
    <script src="../libs/three.min.js"></script>
</head>
<body>
<div id="sim-wrapper">

    <!-- Fullscreen Button -->
    <button id="btn-fullscreen" onclick="toggleFullscreen()">
        <span data-fr="⛶ Plein écran" data-ar="⛶ ملء الشاشة">⛶ Plein écran</span>
    </button>

    <!-- Language Switcher -->
    <button id="btn-lang" onclick="toggleLanguage()">
        <span id="lang-label">العربية</span>
    </button>

    <!-- Zone de Simulation 3D -->
    <div id="canvas-container"></div>

    <!-- Barre Latérale de Contrôle -->
    <div id="sidebar">
        <h2 data-fr="Laboratoire d'Énergie" data-ar="مختبر الطاقة">Laboratoire d'Énergie</h2>

        <div id="instructions">
            <strong data-fr="Guide :" data-ar="الدليل:">Guide :</strong><br>
            <span data-fr="1. Sélectionnez une source." data-ar="1. اختر مصدر الطاقة.">1. Sélectionnez une source.</span><br>
            <span data-fr="2. Activez le flux." data-ar="2. قم بتشغيل التدفق.">2. Activez le flux.</span><br>
            <span data-fr="3. Observez la production électrique." data-ar="3. لاحظ إنتاج الكهرباء.">3. Observez la production électrique.</span>
        </div>

        <br>

        <div class="control-section">
            <h3 data-fr="1. Source d'Énergie" data-ar="1. مصدر الطاقة">1. Source d'Énergie</h3>
            <div class="btn-grid">
                <button id="btn-wind" class="active" onclick="setMode('wind')">
                    <span data-fr="Éolien (Vent)" data-ar="هوائي (رياح)">Éolien (Vent)</span> <span class="status-led"></span>
                </button>
                <button id="btn-hydro" onclick="setMode('hydro')">
                    <span data-fr="Hydraulique (Eau)" data-ar="مائي (ماء)">Hydraulique (Eau)</span> <span class="status-led"></span>
                </button>
                <button id="btn-steam" onclick="setMode('steam')">
                    <span data-fr="Thermique (Feu/Vapeur)" data-ar="حراري (نار/بخار)">Thermique (Feu/Vapeur)</span> <span class="status-led"></span>
                </button>
            </div>
        </div>

        <div class="control-section">
            <h3 data-fr="2. Contrôle du Flux" data-ar="2. التحكم في التدفق">2. Contrôle du Flux</h3>
            <button id="btn-toggle" onclick="togglePower()">
                <span data-fr-on="ARRÊTER FLUX" data-fr-off="ACTIVER FLUX" data-ar-on="إيقاف التدفق" data-ar-off="تشغيل التدفق">ACTIVER FLUX</span>
            </button>
        </div>

        <div class="control-section">
            <h3 data-fr="Production Électrique" data-ar="إنتاج الكهرباء">Production Électrique</h3>
            <div id="power-meter"><div id="power-bar"></div></div>
        </div>

        <div class="control-section">
            <h3 data-fr="Inspection" data-ar="الفحص">Inspection</h3>
            <button id="btn-internals" onclick="toggleInternals()">
                <span data-fr-show="Cacher Interne" data-fr-hide="Vue Rayons X (Intérieur)" data-ar-show="إخفاء الداخل" data-ar-hide="عرض الأشعة السينية (الداخل)">Vue Rayons X (Intérieur)</span>
            </button>
        </div>
    </div>

</div><!-- end #sim-wrapper -->

    <script>
        // --- Variables Globales ---
        let scene, camera, renderer;
        let alternatorGroup, rotor, stator, housing, shaft;
        let turbineGroup, windBlades, waterWheel, steamTurbine;
        let sourceGroup, windSource, hydroSource, steamSource;
        let bulb, bulbLight, bulbFilament;
        let particles = [];
        let labels3D = [];

        const state = {
            mode: 'wind',
            isRunning: false,
            speed: 0,
            maxSpeed: 0.25,
            acceleration: 0.003,
            friction: 0.99,
            showInternals: false,
            currentLang: 'fr'
        };

        // Textes bilingues pour les labels 3D
        const labelTexts = {
            rotor: { fr: 'Rotor (Aimant tournant)', ar: 'الدوار (مغناطيس دوار)' },
            stator: { fr: 'Stator (Bobines fixes)', ar: 'الثابت (ملفات ثابتة)' },
            shaft: { fr: 'Axe de rotation', ar: 'محور الدوران' },
            turbine: { fr: 'Turbine', ar: 'التوربين' },
            wires: { fr: 'Fils électriques', ar: 'أسلاك كهربائية' },
            bulb: { fr: 'Lampe', ar: 'مصباح' },
            wind: { fr: 'Éolienne', ar: 'طاحونة هوائية' },
            hydro: { fr: 'Roue hydraulique', ar: 'عجلة مائية' },
            steam: { fr: 'Turbine à vapeur', ar: 'توربين بخاري' },
            fire: { fr: 'Feu (chauffe l\'eau)', ar: 'نار (تسخين الماء)' },
            boiler: { fr: 'Chaudière', ar: 'غلاية' }
        };

        // Fonction pour changer de langue
        function toggleLanguage() {
            state.currentLang = state.currentLang === 'fr' ? 'ar' : 'fr';
            const html = document.documentElement;
            const langLabel = document.getElementById('lang-label');

            if (state.currentLang === 'ar') {
                html.setAttribute('dir', 'rtl');
                html.setAttribute('lang', 'ar');
                langLabel.textContent = 'Français';
            } else {
                html.setAttribute('dir', 'ltr');
                html.setAttribute('lang', 'fr');
                langLabel.textContent = 'العربية';
            }

            updateAllTexts();
            update3DLabels();
        }

        // Mettre à jour tous les textes de l'interface
        function updateAllTexts() {
            const lang = state.currentLang;

            // Textes simples avec data-fr et data-ar
            document.querySelectorAll('[data-fr]').forEach(el => {
                if (el.dataset[lang]) {
                    el.textContent = el.dataset[lang];
                }
            });

            // Bouton toggle avec états on/off
            const btnToggle = document.querySelector('#btn-toggle span');
            if (btnToggle) {
                const attr = state.isRunning ? `${lang}-on` : `${lang}-off`;
                btnToggle.textContent = btnToggle.dataset[attr] || btnToggle.textContent;
            }

            // Bouton internals avec états show/hide
            const btnInternals = document.querySelector('#btn-internals span');
            if (btnInternals) {
                const attr = state.showInternals ? `${lang}-show` : `${lang}-hide`;
                btnInternals.textContent = btnInternals.dataset[attr] || btnInternals.textContent;
            }
        }

        // Créer un label 3D
        function create3DLabel(text, position, highlight = false) {
            const label = document.createElement('div');
            label.className = 'label-3d' + (highlight ? ' highlight' : '');
            label.textContent = text;
            label.style.position = 'absolute';
            document.getElementById('canvas-container').appendChild(label);

            return {
                element: label,
                position: position.clone(),
                textKey: null
            };
        }

        // Mettre à jour les positions des labels 3D
        function update3DLabels() {
            const container = document.getElementById('canvas-container');
            const lang = state.currentLang;

            labels3D.forEach(label => {
                // Convertir position 3D en position 2D écran
                const vector = label.position.clone();
                vector.project(camera);

                const x = (vector.x * 0.5 + 0.5) * container.clientWidth;
                const y = (vector.y * -0.5 + 0.5) * container.clientHeight;

                label.element.style.left = x + 'px';
                label.element.style.top = y + 'px';

                // Mettre à jour le texte si textKey existe
                if (label.textKey && labelTexts[label.textKey]) {
                    label.element.textContent = labelTexts[label.textKey][lang];
                }

                // Masquer les labels si trop loin ou derrière la caméra
                label.element.style.display = (vector.z < 1) ? 'block' : 'none';
            });
        }

        // Initialiser les labels 3D (sera appelé après la création des objets 3D)
        function init3DLabels() {
            const container = document.getElementById('canvas-container');
            // Nettoyer les anciens labels
            labels3D.forEach(l => l.element.remove());
            labels3D = [];

            const lang = state.currentLang;

            // Label Rotor (à l'intérieur de l'alternateur)
            const rotorLabel = create3DLabel(labelTexts.rotor[lang], new THREE.Vector3(0, 0, 0), true);
            rotorLabel.textKey = 'rotor';
            labels3D.push(rotorLabel);

            // Label Stator
            const statorLabel = create3DLabel(labelTexts.stator[lang], new THREE.Vector3(0, 2, 0), true);
            statorLabel.textKey = 'stator';
            labels3D.push(statorLabel);

            // Label Axe
            const shaftLabel = create3DLabel(labelTexts.shaft[lang], new THREE.Vector3(-3, 0, 1.5));
            shaftLabel.textKey = 'shaft';
            labels3D.push(shaftLabel);

            // Label Turbine (position change selon le mode)
            const turbineLabel = create3DLabel(labelTexts.turbine[lang], new THREE.Vector3(-4.5, 0, -2));
            turbineLabel.textKey = 'turbine';
            labels3D.push(turbineLabel);

            // Label Fils
            const wiresLabel = create3DLabel(labelTexts.wires[lang], new THREE.Vector3(2, -1, 0));
            wiresLabel.textKey = 'wires';
            labels3D.push(wiresLabel);

            // Label Lampe
            const bulbLabel = create3DLabel(labelTexts.bulb[lang], new THREE.Vector3(4, 3, 0));
            bulbLabel.textKey = 'bulb';
            labels3D.push(bulbLabel);
        }

        // Matériaux
        const matSteel = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.3 });
        const matCopper = new THREE.MeshStandardMaterial({ color: 0xb87333, metalness: 0.6, roughness: 0.4 });
        const matDark = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.2, roughness: 0.8 });
        const matBlue = new THREE.MeshPhongMaterial({ color: 0x2196F3 });
        const matWhite = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 });

        // === FIXED DESIGN SIZE SCALING + PINCH-TO-ZOOM ===
        const DESIGN_W = 1024;
        const DESIGN_H = 640;
        const wrapper = document.getElementById('sim-wrapper');
        let userZoom = 1, panX = 0, panY = 0;

        function scaleToFit() {
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            const baseScale = Math.min(vw / DESIGN_W, vh / DESIGN_H);
            const totalScale = baseScale * userZoom;
            wrapper.style.transform = 'translate(' + panX + 'px,' + panY + 'px) scale(' + totalScale + ')';
            wrapper.style.left = ((vw - DESIGN_W * baseScale) / 2) + 'px';
            wrapper.style.top = ((vh - DESIGN_H * baseScale) / 2) + 'px';
        }

        scaleToFit();
        window.addEventListener('resize', function() { userZoom = 1; panX = 0; panY = 0; scaleToFit(); });
        document.addEventListener('fullscreenchange', () => setTimeout(scaleToFit, 100));

        (function() {
            var pinching = false, lastDist = 0, lastMidX = 0, lastMidY = 0, lastTap = 0;
            document.addEventListener('touchstart', function(e) {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    pinching = true;
                    var t1 = e.touches[0], t2 = e.touches[1];
                    lastDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                    lastMidX = (t1.clientX + t2.clientX) / 2;
                    lastMidY = (t1.clientY + t2.clientY) / 2;
                }
            }, { passive: false });
            document.addEventListener('touchmove', function(e) {
                if (!pinching || e.touches.length !== 2) return;
                e.preventDefault();
                var t1 = e.touches[0], t2 = e.touches[1];
                var dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                var midX = (t1.clientX + t2.clientX) / 2;
                var midY = (t1.clientY + t2.clientY) / 2;
                var oldZoom = userZoom;
                userZoom = Math.max(1, Math.min(5, userZoom * (dist / lastDist)));
                var vw = window.innerWidth, vh = window.innerHeight;
                var baseScale = Math.min(vw / DESIGN_W, vh / DESIGN_H);
                var cx = (vw - DESIGN_W * baseScale) / 2;
                var cy = (vh - DESIGN_H * baseScale) / 2;
                var ratio = userZoom / oldZoom;
                panX = panX * ratio + (1 - ratio) * (midX - cx);
                panY = panY * ratio + (1 - ratio) * (midY - cy);
                panX += midX - lastMidX;
                panY += midY - lastMidY;
                lastDist = dist; lastMidX = midX; lastMidY = midY;
                scaleToFit();
            }, { passive: false });
            document.addEventListener('touchend', function(e) {
                if (e.touches.length < 2) pinching = false;
                if (userZoom <= 1.05) { userZoom = 1; panX = 0; panY = 0; scaleToFit(); }
                if (e.touches.length === 0) {
                    var now = Date.now();
                    if (now - lastTap < 300 && userZoom > 1) { userZoom = 1; panX = 0; panY = 0; scaleToFit(); }
                    lastTap = now;
                }
            });
        })();

        init();
        animate();

        function init() {
            // Configuration Scène
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

            // Caméra
            const container = document.getElementById('canvas-container');
            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 3, 17); // Reculée un peu
            camera.lookAt(0, -1, 0); // Regarde légèrement vers le bas

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Lumières
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // Sol (Abaissé pour voir le feu)
            const groundGeo = new THREE.PlaneGeometry(100, 100);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x4caf50 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -6; // Abaissé significativement
            ground.receiveShadow = true;
            scene.add(ground);

            createAlternator();
            createTurbines();
            createSources();
            createBulbAndWires();
            init3DLabels();
            updateModeVisuals();
        }

        function createAlternator() {
            alternatorGroup = new THREE.Group();
            
            // Axe Central
            const shaftGeo = new THREE.CylinderGeometry(0.2, 0.2, 9, 16);
            shaftGeo.rotateZ(Math.PI / 2); 
            shaft = new THREE.Mesh(shaftGeo, matSteel);
            shaft.castShadow = true;
            
            // Rotor
            rotor = new THREE.Group();
            const magnetGeo = new THREE.BoxGeometry(2.5, 1.4, 1.4);
            const magnet = new THREE.Mesh(magnetGeo, matDark);
            
            const poleGeo = new THREE.BoxGeometry(2.4, 0.2, 1.3);
            const nPole = new THREE.Mesh(poleGeo, new THREE.MeshStandardMaterial({color: 'red'}));
            nPole.position.y = 0.8;
            
            const sPole = new THREE.Mesh(poleGeo, new THREE.MeshStandardMaterial({color: 'blue'}));
            sPole.position.y = -0.8;
            
            rotor.add(magnet, nPole, sPole);
            shaft.add(rotor);
            alternatorGroup.add(shaft);

            // Stator
            stator = new THREE.Group();
            const coilGeo = new THREE.TorusGeometry(1.6, 0.3, 16, 50);
            const coil1 = new THREE.Mesh(coilGeo, matCopper);
            coil1.rotation.y = Math.PI / 2; 
            const coil2 = new THREE.Mesh(coilGeo, matCopper);
            coil2.rotation.y = Math.PI / 2;
            coil2.rotation.x = Math.PI / 2;
            stator.add(coil1, coil2);
            alternatorGroup.add(stator);

            // Boîtier
            const housingGeo = new THREE.CylinderGeometry(2.3, 2.3, 4, 32, 1, true);
            housingGeo.rotateZ(Math.PI / 2);
            const housingMat = new THREE.MeshStandardMaterial({ 
                color: 0xcccccc, metalness: 0.5, roughness: 0.5,
                side: THREE.DoubleSide, transparent: true, opacity: 1
            });
            housing = new THREE.Mesh(housingGeo, housingMat);
            const capGeo = new THREE.RingGeometry(0.3, 2.3, 32);
            capGeo.rotateY(Math.PI / 2); 
            const cap1 = new THREE.Mesh(capGeo, housingMat);
            cap1.position.x = 2;
            const cap2 = new THREE.Mesh(capGeo, housingMat);
            cap2.position.x = -2;
            housing.add(cap1, cap2);
            alternatorGroup.add(housing);

            // Pieds (allongés car le sol est plus bas)
            const legGeo = new THREE.BoxGeometry(0.5, 6, 3);
            const leg1 = new THREE.Mesh(legGeo, matDark);
            leg1.position.set(-1.5, -3, 0);
            const leg2 = new THREE.Mesh(legGeo, matDark);
            leg2.position.set(1.5, -3, 0);
            alternatorGroup.add(leg1, leg2);

            scene.add(alternatorGroup);
        }

        function createTurbines() {
            turbineGroup = new THREE.Group();
            turbineGroup.position.set(-4.5, 0, 0); 

            // 1. ÉOLIENNE
            windBlades = new THREE.Group();
            const bladeGeo = new THREE.BoxGeometry(0.6, 7, 0.1); 
            bladeGeo.translate(0, 3.5, 0); 
            for(let i=0; i<3; i++) {
                const blade = new THREE.Mesh(bladeGeo, new THREE.MeshStandardMaterial({color: 'white'}));
                blade.rotation.x = i * (Math.PI * 2 / 3);
                blade.rotation.y = 0.2; 
                windBlades.add(blade);
            }
            const nose = new THREE.Mesh(new THREE.ConeGeometry(0.8, 1.5, 16), new THREE.MeshStandardMaterial({color: 'red'}));
            nose.geometry.rotateZ(Math.PI / 2);
            nose.position.x = -0.5;
            windBlades.add(nose);

            // 2. ROUE HYDRAULIQUE
            waterWheel = new THREE.Group();
            const coreGeo = new THREE.CylinderGeometry(1.5, 1.5, 0.5, 16);
            coreGeo.rotateZ(Math.PI / 2);
            const wCore = new THREE.Mesh(coreGeo, matSteel);
            waterWheel.add(wCore);
            for(let i=0; i<10; i++) {
                const paddleGeo = new THREE.BoxGeometry(0.6, 0.1, 0.8);
                const paddle = new THREE.Mesh(paddleGeo, new THREE.MeshStandardMaterial({color: '#8D6E63'}));
                const angle = i * (Math.PI * 2 / 10);
                const r = 1.5;
                paddle.position.set(0, Math.cos(angle)*r, Math.sin(angle)*r);
                paddle.rotation.x = -angle;
                waterWheel.add(paddle);
            }

            // 3. TURBINE VAPEUR
            steamTurbine = new THREE.Group();
            const casing = new THREE.Mesh(
                new THREE.CylinderGeometry(1.6, 1.6, 1, 16).rotateZ(Math.PI/2),
                new THREE.MeshStandardMaterial({color: '#555', transparent:true, opacity:0.4})
            );
            const sRotor = new THREE.Group();
            for(let i=0; i<16; i++) {
                const blade = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.4, 0.05), matSteel);
                const angle = i * (Math.PI * 2 / 16);
                blade.position.set(0, Math.cos(angle)*0.8, Math.sin(angle)*0.8);
                blade.rotation.x = -angle;
                blade.rotation.y = 0.5; 
                sRotor.add(blade);
            }
            steamTurbine.add(casing);
            steamTurbine.add(sRotor);
            steamTurbine.userData.rotor = sRotor;

            turbineGroup.add(windBlades, waterWheel, steamTurbine);
            scene.add(turbineGroup);
        }

        function createSources() {
            sourceGroup = new THREE.Group();

            // HYDRO Source
            hydroSource = new THREE.Group();
            const tank = new THREE.Mesh(new THREE.BoxGeometry(3, 2, 3), new THREE.MeshStandardMaterial({color: '#78909C'}));
            tank.position.set(-4.5, 4.5, 0);
            const nozzle = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 1.5), matSteel);
            nozzle.position.set(-4.5, 3, 0);
            
            // Support réservoir (longs poteaux)
            const postGeo = new THREE.CylinderGeometry(0.1, 0.1, 10.5);
            const p1 = new THREE.Mesh(postGeo, matSteel); p1.position.set(-5.8, -0.75, 1.3);
            const p2 = new THREE.Mesh(postGeo, matSteel); p2.position.set(-3.2, -0.75, 1.3);
            hydroSource.add(tank, nozzle, p1, p2);

            // --- STEAM Source (Chaudière Industrielle Redessinée) ---
            steamSource = new THREE.Group();
            
            // 1. Foyer (Briques)
            const furnaceGeo = new THREE.BoxGeometry(2.5, 2, 2.5);
            const furnaceMat = new THREE.MeshStandardMaterial({color: 0x8D6E63, roughness: 0.9}); 
            const furnace = new THREE.Mesh(furnaceGeo, furnaceMat);
            furnace.position.set(-4.5, -5, 0); // Au sol
            
            // Ouverture du foyer - RENDUE PLUS GRANDE
            const holeGeo = new THREE.BoxGeometry(1.8, 1.5, 2.6); // Agrandie
            const holeMat = new THREE.MeshBasicMaterial({color: 0x111111}); 
            const hole = new THREE.Mesh(holeGeo, holeMat);
            hole.position.set(0, -0.2, 0);
            furnace.add(hole);

            // 2. Corps Chaudière (Cylindre horizontal)
            const boilerGeo = new THREE.CylinderGeometry(1.2, 1.2, 3.5, 32);
            boilerGeo.rotateZ(Math.PI / 2);
            const boilerMat = new THREE.MeshStandardMaterial({color: 0x555555, roughness: 0.4});
            const boiler = new THREE.Mesh(boilerGeo, boilerMat);
            boiler.position.set(-4.5, -3.5, 0); 
            
            // 3. Cheminée
            const chimneyGeo = new THREE.CylinderGeometry(0.3, 0.4, 5);
            const chimney = new THREE.Mesh(chimneyGeo, new THREE.MeshStandardMaterial({color: 0x333333}));
            chimney.position.set(-5.8, -1.5, 0);
            
            // 4. Tuyau connexion vapeur - REDESSINÉ
            // Tuyau vertical qui monte de la chaudière vers l'entrée turbine
            const pipeGeo = new THREE.CylinderGeometry(0.15, 0.15, 2.2);
            const pipe = new THREE.Mesh(pipeGeo, matSteel);
            // Positionné pour connecter le haut de la chaudière (y=-2.3) au bas de la turbine (y=-1.5)
            // Centre du tuyau approx à y=-2.4
            pipe.position.set(-4.5, -2.4, 0);
            
            // --- NOUVEAU FEU DYNAMIQUE - POSITION AJUSTÉE ---
            const fireGroup = new THREE.Group();
            const fireColors = [0xFF5722, 0xFF9800, 0xFFEB3B]; 
            
            for(let i=0; i<30; i++) {
                const flameGeo = new THREE.ConeGeometry(0.15, 0.6, 8);
                const color = fireColors[Math.floor(Math.random()*fireColors.length)];
                const flame = new THREE.Mesh(flameGeo, new THREE.MeshBasicMaterial({color: color}));
                
                // Position avancée vers l'ouverture (z positif) pour visibilité
                const r = Math.random() * 0.7;
                const angle = Math.random() * Math.PI * 2;
                flame.position.set(
                    -4.5 + Math.cos(angle)*r, 
                    -5.5, 
                    Math.sin(angle)*r + 0.5 // Décalé vers l'avant
                );
                
                flame.userData = { 
                    speed: 5 + Math.random() * 5, 
                    offset: Math.random() * 100, 
                    baseScale: 0.6 + Math.random() * 0.8 
                };
                fireGroup.add(flame);
            }
            
            // Lumière intense du feu
            const fireLight = new THREE.PointLight(0xFF5722, 2, 10);
            fireLight.position.set(-4.5, -5, 1); // Lumière aussi avancée
            fireGroup.add(fireLight);

            steamSource.userData.fire = fireGroup;
            steamSource.add(furnace, boiler, chimney, pipe, fireGroup);

            scene.add(hydroSource);
            scene.add(steamSource);
        }

        function createBulbAndWires() {
            const bulbGroup = new THREE.Group();
            bulbGroup.position.set(4, 2, 0);

            // Ampoule
            bulb = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 32), new THREE.MeshPhongMaterial({
                color: 0xffffee, transparent: true, opacity: 0.8, shininess: 100, emissive: 0xffaa00, emissiveIntensity: 0
            }));
            const socket = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 0.8), matSteel);
            socket.position.y = -1;
            bulbLight = new THREE.PointLight(0xffaa00, 0, 15);
            
            bulbGroup.add(bulb, socket, bulbLight);
            scene.add(bulbGroup);

            // --- CÂBLES RÉALISTES (Sortie directe des bobines) ---
            
            // On supprime la 'connBox' pour que les fils sortent du corps de la machine

            // Points pour les fils
            // Les fils sortent maintenant du côté bas de l'alternateur (proche des bobines stator)
            
            // Fil 1 (Rouge / Positif)
            // Départ: x=0.5 (un peu à droite du centre), y=-1.5 (bas), z=0.8 (avant)
            const start1 = new THREE.Vector3(0.5, -1.5, 0.8); 
            const end1 = new THREE.Vector3(4, 0.8, 0.2);     // Bas du culot ampoule
            // Point de contrôle bas pour faire une courbe pendante (gravité)
            const mid1 = new THREE.Vector3(2.5, -2.5, 0.5);   
            
            const curve1 = new THREE.QuadraticBezierCurve3(start1, mid1, end1);
            const tube1 = new THREE.Mesh(
                new THREE.TubeGeometry(curve1, 20, 0.06, 8, false), 
                new THREE.MeshStandardMaterial({color: 0xD32F2F}) // Rouge
            );

            // Fil 2 (Bleu / Négatif)
            // Départ: symétrique en Z
            const start2 = new THREE.Vector3(0.5, -1.5, -0.8); 
            const end2 = new THREE.Vector3(4, 0.8, -0.2);     // Bas du culot ampoule
            const mid2 = new THREE.Vector3(2.5, -2.5, -0.5);  // Point de contrôle bas
            
            const curve2 = new THREE.QuadraticBezierCurve3(start2, mid2, end2);
            const tube2 = new THREE.Mesh(
                new THREE.TubeGeometry(curve2, 20, 0.06, 8, false), 
                new THREE.MeshStandardMaterial({color: 0x1976D2}) // Bleu
            );

            // Ajout de petits connecteurs à la base pour faire "propre"
            const terminalGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.5);
            terminalGeo.rotateX(Math.PI/2);
            const term1 = new THREE.Mesh(terminalGeo, matDark);
            term1.position.copy(start1);
            term1.position.z -= 0.1; // Ajustement léger
            
            const term2 = new THREE.Mesh(terminalGeo, matDark);
            term2.position.copy(start2);
            term2.position.z += 0.1;

            scene.add(tube1, tube2, term1, term2);
        }

        function setMode(mode) {
            state.mode = mode;
            state.isRunning = false;

            // Mettre à jour le texte du bouton toggle selon la langue
            const btnToggleSpan = document.querySelector('#btn-toggle span');
            const lang = state.currentLang;
            btnToggleSpan.textContent = btnToggleSpan.dataset[`${lang}-off`];

            document.getElementById('btn-toggle').style.backgroundColor = "#f1c40f";
            document.getElementById('btn-toggle').style.color = "#333";

            document.querySelectorAll('#sidebar button').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-' + mode).classList.add('active');
            updateModeVisuals();
        }

        function togglePower() {
            state.isRunning = !state.isRunning;
            const btn = document.getElementById('btn-toggle');
            const btnSpan = btn.querySelector('span');
            const lang = state.currentLang;

            if(state.isRunning) {
                btnSpan.textContent = btnSpan.dataset[`${lang}-on`];
                btn.style.backgroundColor = "#e74c3c";
                btn.style.color = "white";
            } else {
                btnSpan.textContent = btnSpan.dataset[`${lang}-off`];
                btn.style.backgroundColor = "#f1c40f";
                btn.style.color = "#333";
            }
        }

        function toggleInternals() {
            state.showInternals = !state.showInternals;
            const btn = document.getElementById('btn-internals');
            const btnSpan = btn.querySelector('span');
            const lang = state.currentLang;

            if(state.showInternals) {
                housing.material.opacity = 0.2;
                btnSpan.textContent = btnSpan.dataset[`${lang}-show`];
            } else {
                housing.material.opacity = 1;
                btnSpan.textContent = btnSpan.dataset[`${lang}-hide`];
            }
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().then(() => {
                    if (screen.orientation && screen.orientation.lock) {
                        screen.orientation.lock('landscape').catch(() => {});
                    }
                    scaleToFit();
                }).catch(() => {});
            } else {
                document.exitFullscreen();
                scaleToFit();
            }
        }

        function updateModeVisuals() {
            windBlades.visible = (state.mode === 'wind');
            waterWheel.visible = (state.mode === 'hydro');
            steamTurbine.visible = (state.mode === 'steam');
            
            hydroSource.visible = (state.mode === 'hydro');
            steamSource.visible = (state.mode === 'steam');
            
            particles.forEach(p => scene.remove(p));
            particles = [];
        }

        function spawnParticle() {
            if(!state.isRunning) return;
            let pMesh;
            let pData = { life: 90, velocity: new THREE.Vector3() };

            if(state.mode === 'wind') {
                const geo = new THREE.BoxGeometry(0.5, 0.05, 0.05);
                pMesh = new THREE.Mesh(geo, matWhite);
                pMesh.position.set(-15, (Math.random()-0.5)*5, (Math.random()-0.5)*5);
                pData.velocity.set(0.4, 0, 0);
            }
            else if(state.mode === 'hydro') {
                const geo = new THREE.SphereGeometry(0.15, 6, 6);
                pMesh = new THREE.Mesh(geo, matBlue);
                pMesh.position.set(-4.5 + (Math.random()-0.5)*0.2, 3, (Math.random()-0.5)*0.2);
                pData.velocity.set(0, -0.25, 0);
            }
            else if(state.mode === 'steam') {
                const geo = new THREE.SphereGeometry(0.25, 6, 6);
                pMesh = new THREE.Mesh(geo, matWhite);
                // Départ sortie du tuyau (juste sous la turbine)
                // Turbine est à y=0, bas approx y=-1.5
                pMesh.position.set(-4.5 + (Math.random()-0.5)*0.2, -1.4, (Math.random()-0.5)*0.2); 
                pData.velocity.set(0, 0.15, 0); // Monte verticalement dans les pales
                pData.life = 60; 
            }

            if(pMesh) {
                pMesh.userData = pData;
                scene.add(pMesh);
                particles.push(pMesh);
            }
        }

        function updateParticles() {
            if(state.isRunning && Math.random() > 0.6) spawnParticle();
            
            for(let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.velocity);
                p.userData.life--;
                p.rotation.z += 0.1;
                
                // Effet de grossissement pour la vapeur
                if(state.mode === 'steam') {
                    p.scale.multiplyScalar(1.03);
                    p.material.opacity = p.userData.life / 60;
                }

                if(p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }
        }

        function onWindowResize() {
            // Container size is fixed (wrapper is 1024x640, sidebar is 260px)
            // No need to resize the renderer — just rescale the wrapper
            scaleToFit();
        }

        function animate() {
            requestAnimationFrame(animate);

            if (state.isRunning) {
                if (state.speed < state.maxSpeed) state.speed += state.acceleration;
            } else {
                if (state.speed > 0) state.speed -= state.friction * 0.005;
                if (state.speed < 0) state.speed = 0;
            }

            const rot = state.speed;
            shaft.rotation.x += rot;

            if(state.mode === 'wind') {
                windBlades.rotation.x += rot;
            } 
            else if(state.mode === 'hydro') {
                waterWheel.rotation.x += rot;
            } 
            else if(state.mode === 'steam') {
                steamTurbine.userData.rotor.rotation.x += rot;
                
                // Animation Feu Améliorée
                if(steamSource.visible && steamSource.userData.fire) {
                    const time = Date.now() * 0.01; // Plus rapide
                    steamSource.userData.fire.children.forEach(flame => {
                        if (flame.type === 'Mesh') {
                            // Scintillement rapide et variation de taille
                            flame.scale.y = flame.userData.baseScale + Math.sin(time * flame.userData.speed + flame.userData.offset) * 0.3;
                            flame.rotation.y += 0.1; // Tourne un peu pour effet 3D
                        }
                    });
                    // La lumière vacille aussi
                    const light = steamSource.userData.fire.children.find(c => c.type === 'PointLight');
                    if(light) light.intensity = 1.5 + Math.sin(time * 10) * 0.5;
                }
            }

            updateParticles();
            update3DLabels();

            const intensity = state.speed / state.maxSpeed;
            bulb.material.emissiveIntensity = intensity * 2.5;
            bulbLight.intensity = intensity * 2;
            document.getElementById('power-bar').style.width = (intensity * 100) + '%';

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>